const { TransformVisitor, utils } = require('@antchain/deps/visitor-as');
const { Parser, CommonFlags } = require('@antchain/deps/visitor-as/as');

const mockFunctions = [
  // account
  'getOrigin',
  'getSender',
  'getSelf',
  'checkAccount',
  'getAccountStatus',
  'getBalance',
  'getRecoverKey',
  'getAuthMap',

  // block
  'getBlockNumber',
  'getBlockTimeStamp',
  'getBlockHash',

  // contract
  'getGas',
  'getValue',
  'getCode',
  'getCodeHash',

  // general
  'digest',
  'getTargetAddress',

  // transaction
  'isLocalTx',
  'getTxHash',
  'getData',
  'getRelatedTxListSize',
  'getRelatedTxList',
  'getTxSender',
  'getTxReceiver',
  'getTxData',
  'getTxTimestamp',
  'getTxBlockIndex',
  'getTxDepositFlag',
  'getConfidentialDepositData',
  'getConfidentialDepositFlag',
];

function getStatements(code, path) {
  const parser = new Parser();
  parser.parseFile(code, path + '.ts', true);
  return parser.sources[0].statements;
}

function changeFunctionBody(node, code) {
  const path = node.range.source.internalPath;
  node.body.statements = getStatements(code, path);
}

module.exports = class extends TransformVisitor {
  // ç»™æ¯ä¸ªæ–‡ä»¶éƒ½ import mock
  visitSource(node) {
    node.statements = [
      ...getStatements(`import { mock } from '..';`, node.internalPath),
      ...node.statements,
    ];
    return super.visitSource(node);
  }

  // æŠŠè¦ mock çš„å‡½æ•°é‡Œçš„ä»£ç æ”¹æ‰
  visitFunctionDeclaration(node) {
    const name = utils.getName(node);
    const params = node.signature.parameters.map((p) => utils.getName(p)).join(',');
    if (node.is(CommonFlags.EXPORT) && mockFunctions.indexOf(name) !== -1) {
      const code = `
        if (mock.my.${name}.cacheFn != null) {
          return mock.my.${name}.cacheFn(${params});
        } else {
          return mock.my.${name}.cacheReturnValue;
        }
      `;
      changeFunctionBody(node, code);
    }
    if (node.is(CommonFlags.EXPORT) && name === 'println<T>') {
      changeFunctionBody(node, `log(${params});`);
    }
    return super.visitFunctionDeclaration(node);
  }

  afterParse({ sources }) {
    // éå† my.xxx çš„ä»£ç 
    const chainSources = sources.filter((s) => s.internalPath.indexOf('myassembly/chain/') !== -1);
    this.visit(chainSources);

    // æŸ¥çœ‹ç”Ÿæˆçš„ä»£ç 
    // chainSources.forEach((s) => {
    //   console.log('ğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸğŸŸ\n');
    //   console.log(s.internalPath + '\n');
    //   console.log(utils.toString(s));
    // });
  }
};
