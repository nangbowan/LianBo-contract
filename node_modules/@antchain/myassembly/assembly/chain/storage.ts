import { ENV, utils } from '..';

/**
 * Key-Value 存储
 * @param key string
 * @param value 仅支持可序列化的数据
 */
export function setStorage<T>(key: string, value: T): void {
  const keyBytes = utils.getBytes(key);
  const valueBytes = utils.serialize(value);
  const res = ENV.SetStorage(
    keyBytes.dataStart as u32,
    keyBytes.byteLength,
    valueBytes.dataStart as u32,
    valueBytes.byteLength,
  );
  assert(res === 0, `[setStorage] execute failed, key: ${key}`);
}

/**
 * 根据 Key 获取数据大小
 * @param key string
 * @returns 大小
 */
export function getStorageSize(key: string): u32 {
  const keyBytes = utils.getBytes(key);
  const storageSizePtr = utils.allocLength();

  // 获取数据大小
  const res = ENV.GetStorageSize(
    keyBytes.dataStart as u32,
    keyBytes.byteLength,
    storageSizePtr as u32,
  );
  assert(res === 0, `[getStorageSize] execute failed, key: ${key}`);

  const dataSize = load<u32>(storageSizePtr);
  assert(dataSize <= ENV.StorageLimit, `[getStorageSize] size overflow, key: ${key}`);

  return dataSize;
}

/**
 * 根据 Key 获取数据
 * @param key string
 * @returns 反序列化之后的数据
 */
export function getStorage<T>(key: string): T {
  const keyBytes = utils.getBytes(key);
  const storageSize = getStorageSize(key);

  const data = utils.allocData(storageSize);

  // 获取数据
  const res = ENV.GetStorage(
    keyBytes.dataStart as u32,
    keyBytes.byteLength,
    data.ptr,
    data.lengthPtr,
  );
  assert(res === 0, `[getStorage] execute failed, key: ${key}`);

  // 反序列化
  return utils.unserialize<T>(data.bytes);
}

/**
 * 根据 Key 删除数据
 * @param key string
 */
export function deleteStorage(key: string): void {
  const keyBytes = utils.getBytes(key);
  const res = ENV.DeleteStorage(keyBytes.dataStart as u32, keyBytes.byteLength);
  assert(res === 0, `[deleteStorage] execute failed, key: ${key}`);
}
