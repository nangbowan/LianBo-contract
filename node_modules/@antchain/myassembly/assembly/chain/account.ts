import { ENV, Identity, utils, assert } from '..';

/**
 * 获取交易发起者的 id
 * @returns Identity
 */
export function getOrigin(): Identity {
  const data = utils.allocData(ENV.IdentityLength);
  const res = ENV.GetOrigin(data.ptr, data.lengthPtr);
  assert(res === 0, '[getOrigin] failed');
  return Identity.fromBytes(data.bytes);
}

/**
 * 获取调用者的 id（账户或合约），合约执行会消耗 sender 的 gas
 * @returns Identity
 */
export function getSender(): Identity {
  const data = utils.allocData(ENV.IdentityLength);
  const res = ENV.GetSender(data.ptr, data.lengthPtr);
  assert(res === 0, '[getSender] failed');
  return Identity.fromBytes(data.bytes);
}

/**
 * 获取本合约的 id
 * @returns Identity
 */
export function getSelf(): Identity {
  const data = utils.allocData(ENV.IdentityLength);
  const res = ENV.GetSelf(data.ptr, data.lengthPtr);
  assert(res === 0, '[getSelf] failed');
  return Identity.fromBytes(data.bytes);
}

/**
 * 检查 id 指定的账户是否存在
 * @param id Identity
 * @returns bool
 */
export function checkAccount(id: Identity): bool {
  return bool(ENV.CheckAccount(id.ptr, id.length));
}

// 账户状态
export enum AccountStatus {
  // 正常
  NORMAL = 0,
  // 冻结
  FREEZE = 1,
  // 恢复中
  RECOVERING = 2,
  // 不存在，由 myfish 定义
  NOT_EXIST = 1000,
}

/**
 * 获取 id 指定账户的状态
 * @param id Identity
 * @returns AccountStatus
 */
export function getAccountStatus(id: Identity): AccountStatus {
  const statusPtr = new Uint32Array(1).dataStart as u32;
  const res = ENV.GetAccountStatus(id.ptr, id.length, statusPtr);
  return res === 0 ? load<u32>(statusPtr) : AccountStatus.NOT_EXIST;
}

/**
 * 获取 id 指定账户的余额
 * @param id Identity
 * @returns u64
 */
export function getBalance(id: Identity): u64 {
  const data = utils.allocData(8);
  const res = ENV.GetBalance(id.ptr, id.length, data.ptr);
  assert(res === 0, `[getBalance] failed, id: ${id.str}`);
  return load<u64>(data.ptr);
}

/**
 * 获取 id 指定账户的恢复公钥
 * @param id Identity
 * @returns string
 */
export function getRecoverKey(id: Identity): string {
  const data = utils.allocData(ENV.HashLength);
  const res = ENV.GetRecoverKey(id.ptr, id.length, data.ptr, data.lengthPtr);
  assert(res === 0, `[getRecoverKey] failed, id: ${id.str}`);
  return utils.bytesToHexString(data.bytes);
}

/**
 * 获取 id 指定账户的权限列表
 * @param id Identity
 * @returns Map<公钥, 权重>
 */
export function getAuthMap(id: Identity): Map<Identity, u32> {
  // 获取数据
  const data = utils.allocData(ENV.StorageLimit);
  const res = ENV.GetAuthMap(id.ptr, id.length, data.ptr, data.lengthPtr);
  const actualDataLength = load<u32>(data.lengthPtr);
  assert(res === 0, `[getAuthMap] failed, id: ${id.str}`);
  assert(actualDataLength <= ENV.StorageLimit, `[getAuthMap] length overflow id: ${id.str}`);

  const srcMap = utils.unserialize<Map<string, u32>>(data.bytes);
  const authMap = new Map<Identity, u32>();

  // 转换 keys string -> Identity
  const keys = srcMap.keys();
  for (let i = 0; i < keys.length; i += 1) {
    authMap.set(Identity.fromStr(keys[i]), srcMap.get(keys[i]));
  }
  return authMap;
}
