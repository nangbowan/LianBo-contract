import { ENV, Identity, utils } from '..';

/**
 * 打印日志，会记入交易回执
 * @param data 可被序列化的数据
 * @param topics string[]
 */
export function log<T>(data: T, topics: string[]): void {
  const dataBytes = utils.serialize(data);
  const topicsBytes = utils.serialize(topics);
  const res = ENV.Log(
    dataBytes.dataStart as u32,
    dataBytes.byteLength,
    topicsBytes.dataStart as u32,
    topicsBytes.byteLength,
  );
  assert(res === 0, '[log] execute failed');
}

/**
 * 终止合约执行
 * @param message 错误信息
 */
export function abort(message: string): void {
  const bytes = utils.getBytes(message);
  ENV.MyAbort(bytes.dataStart as u32, bytes.byteLength);
}

/**
 * 断言一个表达式，如果是 false 就终止合约执行
 * @param truthy  表达式的结果
 * @param message 错误信息
 */
export function assert(truthy: bool, message: string): void {
  if (!truthy) {
    abort(message);
  }
}

/**
 * 从缓存中读取数据
 * @param length 数据长度
 * @param message 读取失败的错误信息
 * @returns bytes
 */
export function readBuffer(length: u32, message: string): Uint8Array {
  const data = utils.allocData(length);
  assert(ENV.ReadBuffer(data.ptr, length) === 0, message);
  return data.bytes;
}

/**
 * 用指定的算法做一次哈希
 * @param msg 源信息
 * @param type 算法类型
 * @returns 哈希值
 */
export function digest(msg: string, type: ENV.DigestType): string {
  const bytes = utils.getBytes(msg);
  const data = utils.allocData(ENV.HashLength);
  const res = ENV.Digest(
    bytes.dataStart as u32,
    bytes.byteLength,
    type as u16,
    data.ptr,
    data.lengthPtr,
  );
  assert(res === 0, `[digest] execute failed, msg: ${msg}`);
  return utils.bytesToHexString(data.bytes);
}

/**
 * 用平台指定的算法，计算 target 地址（做一次哈希）
 * @param target string
 * @returns Identity
 */
export function getTargetAddress(target: string): Identity {
  return Identity.fromStr(digest(target, ENV.GetDigestType()));
}
