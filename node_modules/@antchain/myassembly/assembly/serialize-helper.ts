import { Variant, utils, assert } from '.';

/**
 * 序列化读写工具
 *  - 在末尾添加新的数据
 *  - 逐个读取指定类型的数据
 * @param bytes
 */
export class SerializeHelper {
  bytes: Uint8Array;
  index: u32 = 0;

  constructor(bytes: Uint8Array = new Uint8Array(0)) {
    this.bytes = bytes;
  }

  // 获取序列化过的合约参数字节流
  static getParamBytes(params: Variant[]): Uint8Array {
    const helper = new SerializeHelper();
    for (let i = 0; i < params.length; i += 1) {
      helper.add(params[i]);
    }
    return helper.bytes;
  }

  // 在末尾添加新数据，支持可序列化的类型，或 Variant 类型
  public add<T>(value: T): void {
    // 非 Variant 类型，直接添加
    if (!(value instanceof Variant)) {
      this.concat(value);
      return;
    }

    // Variant 要尝试所有的可序列化的类型
    assert(
      [
        this.concatVar<bool>(value),
        this.concatVar<i8>(value),
        this.concatVar<i16>(value),
        this.concatVar<i32>(value),
        this.concatVar<i64>(value),
        this.concatVar<u8>(value),
        this.concatVar<u16>(value),
        this.concatVar<u32>(value),
        this.concatVar<u64>(value),
        this.concatVar<u64>(value),
        this.concatVar<f32>(value),
        this.concatVar<f64>(value),
        this.concatVar<string>(value),
      ].some((valid) => valid),
      '[SerializeHelper] execute failed - the Variant unable to serialize',
    );
  }

  // 在末尾添加新的可序列化的数据
  private concat<T>(value: T): void {
    this.bytes = utils.concatBytes(this.bytes, utils.serialize(value));
  }

  // 在末尾添加新的 Variant 类型的数据
  private concatVar<T>(value: Variant): bool {
    if (value.is<T>()) {
      this.concat(value.get<T>());
      return true;
    }

    // 方便起见，同时尝试一下 T[] 类型
    if (value.is<T[]>()) {
      this.concat(value.get<T[]>());
      return true;
    }

    return false;
  }

  // 读取一个数据
  public read<T>(): T {
    this.checkIndex();
    const readBytes = this.bytes.subarray(this.index);
    this.index += utils.getSerializedBytesLength<T>(readBytes);
    return utils.unserialize<T>(readBytes);
  }

  // 检查是否越界
  private checkIndex(): void {
    assert((this.index as number) < this.bytes.byteLength, 'SerializeHelper read overflow');
  }
}
