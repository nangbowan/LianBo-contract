import { getBytes } from './bytes';

/**
 * 把 Unsigned Integer 转成 LEB128 编码
 * 算法参考：https://en.wikipedia.org/wiki/LEB128
 * @param value number
 * @returns 字节码
 */
export function encodeUintToLEB128(value: u32): Uint8Array {
  let v = value;

  // 创建一个数组，用来存放 LEB128 字节码
  const arr = new Array<u8>(0);

  /* eslint-disable no-bitwise */
  do {
    // 获取低位的 7 bits（字节码的左侧为低位）
    const byte = getBytes(v & 0x7f)[0];

    // 以 7 bits 为单位，右移处理下一个
    v >>= 7;

    // 如果右移之后是零，说明这是最后一个，不用操作，最高位是 0
    // 否则，就把最高位设置为 1
    arr.push(v === 0 ? byte : byte | 0x80);

    // 如果下一个不是零，说明要继续操作
  } while (v !== 0);
  /* eslint-enable */

  // 把数组转成 LEB128 字节码
  const LEB128 = new Uint8Array(arr.length);
  for (let i = 0; i < arr.length; i += 1) {
    LEB128[i] = arr[i];
  }

  return LEB128;
}

/**
 * 把 LEB128 解码到 Unsigned Integer
 * 算法参考：https://en.wikipedia.org/wiki/LEB128
 * @param bytes 字节码
 * @returns number
 */
export function decodeLEB128ToUint(bytes: Uint8Array): u32 {
  let value: u32 = 0;

  // 获取开头的 LEB128 字节码
  const leb128 = getLEB128FromBytes(bytes);

  /* eslint-disable no-bitwise */
  for (let i = 0; i < leb128.byteLength; i += 1) {
    // 把 byte 强制赋值到一个 u32 变量，为了下一步的左移操作
    const n: u32 = leb128[i];

    // 取低位 7 bits 并左移，再保存到 value 中
    value |= (n & 0x7f) << (i * 7);
  }
  /* eslint-enable */

  return value;
}

/**
 * 解析字节码，获取开头的 LEB128 字节码
 * @param bytes 字节码
 * @returns LEB128 字节码
 */
export function getLEB128FromBytes(bytes: Uint8Array): Uint8Array {
  let length = 0;

  /* eslint-disable no-bitwise */
  for (let i = 0; i < bytes.byteLength; i += 1) {
    length += 1;

    // 最高位是 0 代表这是最后一个，停止解析
    if ((bytes[i] & 0x80) === 0) {
      break;
    }
  }
  /* eslint-enable */

  return bytes.subarray(0, length);
}
