/**
 * 把数据转成字节码
 * @param value 原数据
 * @returns 字节码
 */
export function getBytes<T>(value: T): Uint8Array {
  let bytes = new Uint8Array(0);

  // 不能直接 isNullable<T>() && value === null
  // 因为 AS 在编译时，暂时不支持这种复杂的动态判断
  if (isNullable<T>()) {
    if (value === null) {
      return bytes;
    }
  }

  // array 递归
  if (isArray<T>()) {
    // @ts-ignore
    return getArrayBytes(value);
  }

  // number and boolean
  if (isInteger<T>() || isFloat<T>()) {
    bytes = new Uint8Array(sizeof<T>());
    store<T>(bytes.dataStart, value);
  }

  if (isString<T>()) {
    // @ts-ignore
    bytes = Uint8Array.wrap(String.UTF8.encode(value));
  }

  // AS 不支持 Union Types
  // https://www.assemblyscript.org/status.html#union-types
  if (
    value instanceof Int8Array ||
    value instanceof Int16Array ||
    value instanceof Int32Array ||
    value instanceof Int64Array ||
    value instanceof Uint8Array ||
    value instanceof Uint16Array ||
    value instanceof Uint32Array ||
    value instanceof Uint64Array ||
    value instanceof Uint8ClampedArray ||
    value instanceof Float32Array ||
    value instanceof Float64Array
  ) {
    bytes = Uint8Array.wrap(value.buffer);
  }

  // TODO: 理论上要支持任意类型的数据

  return bytes;
}

/**
 * 把数组转成字节码
 * @param value 原数据
 * @returns 字节码
 */
function getArrayBytes<T>(arr: T[]): Uint8Array {
  return arr.reduce((bytes, value) => {
    return concatBytes(bytes, getBytes(value));
  }, new Uint8Array(0));
}

/**
 * 把字节码转成底层的 buffer
 * @param bytes 字节码
 * @returns buffer
 */
export function bytesToBuffer(bytes: Uint8Array): ArrayBuffer {
  return bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
}

/**
 * 把字节码转成 DataView
 * @param bytes 字节码
 * @returns DataView
 */
export function bytesToDataView(bytes: Uint8Array): DataView {
  return new DataView(bytesToBuffer(bytes));
}

/**
 * 合并两个字节码
 * @param a
 * @param b
 * @returns 合并结果（字节码）
 */
export function concatBytes(a: Uint8Array, b: Uint8Array): Uint8Array {
  const res = new Uint8Array(a.byteLength + b.byteLength);
  memory.copy(res.dataStart, a.dataStart, a.byteLength);
  memory.copy(res.dataStart + a.byteLength, b.dataStart, b.byteLength);
  return res;
}

/**
 * 把字节码转成 16 进制 hash 字符串
 * @param bytes 字节码
 * @returns 字符串，没有 0x 前缀
 */
export function bytesToHexString(bytes: Uint8Array): string {
  const dv = bytesToDataView(bytes);

  // 把每个字节都转成 16 进制的字符串
  let res = '';
  for (let i = 0; i < dv.byteLength; i += 1) {
    const str = dv.getUint8(i).toString(16);
    const pre = str.length === 1 ? '0' : '';
    res += `${pre}${str}`;
  }
  return res;
}

/**
 * 把 16 进制 hash 字符串转成 字节码
 * @param 字符串，没有 0x 前缀
 * @returns bytes 字节码
 */
export function hexStringToBytes(hex: string): Uint8Array {
  assert(hex.length % 2 == 0, `[hexStringToBytes] "${hex}" has odd length`);
  const res = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    res[i / 2] = I8.parseInt(hex.substr(i, 2), 16);
  }
  return res;
}
