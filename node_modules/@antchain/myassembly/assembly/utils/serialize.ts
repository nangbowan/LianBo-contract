import { encodeUintToLEB128, decodeLEB128ToUint, getLEB128FromBytes } from './leb128';
import { getBytes, concatBytes, bytesToBuffer } from './bytes';
import { SerializeHelper, assert } from '..';

/**
 * 检查 T 类型是否可被序列化
 * 只支持基础数据类型：
 *  - number
 *  - boolean
 *  - string
 * 以及包含这些类型的 array 或 map（支持嵌套）
 */
export function checkSerializeType<T>(): void {
  // array 递归
  if (isArray<T>()) {
    // @ts-ignore
    checkSerializeType<valueof<T>>();
    return;
  }

  // map 递归
  let map!: T;
  if (map instanceof Map) {
    // @ts-ignore
    checkSerializeType<indexof<T>>();
    // @ts-ignore
    checkSerializeType<valueof<T>>();
    return;
  }

  assert(
    isInteger<T>() || isFloat<T>() || isString<T>(),
    `type ${nameof<T>()} unable to serialize`,
  );
}

/**
 * 序列化，在合同交互和数据存储之前，需要对数据进行编码
 * @param value 原数据
 * @returns 字节码
 */
// eslint-disable-next-line consistent-return
export function serialize<T>(value: T): Uint8Array {
  checkSerializeType<T>();

  // array 递归
  if (isArray<T>()) {
    // @ts-ignore
    return serializeArray<valueof<T>>(value);
  }

  // map 递归
  if (value instanceof Map) {
    // @ts-ignore
    return serializeMap<indexof<T>, valueof<T>>(value);
  }

  // number or boolean 直接转成字节码即可
  if (isInteger<T>() || isFloat<T>()) {
    return getBytes<T>(value);
  }

  // string 前面需要加上 LEB128 编码的 byteLength
  if (isString<T>()) {
    const strBytes = getBytes(value);
    const lenBytes = encodeUintToLEB128(strBytes.byteLength);
    return concatBytes(lenBytes, strBytes);
  }

  unreachable();
}

/**
 * 序列化数组
 * @param arr 原数据
 * @returns 字节码
 */
function serializeArray<T>(arr: T[]): Uint8Array {
  // 每一项都进行序列化，并合并
  let bytes = new Uint8Array(0);
  for (let i = 0; i < arr.length; i += 1) {
    bytes = concatBytes(bytes, serialize(arr[i]));
  }

  // 前面需要加上 LEB128 编码的数组长度
  const lenBytes = encodeUintToLEB128(arr.length);
  return concatBytes(lenBytes, bytes);
}

/**
 * 序列化 map
 * @param map 原数据
 * @returns 字节码
 */
function serializeMap<K, V>(map: Map<K, V>): Uint8Array {
  const keys = map.keys();

  // 每一项都进行序列化，并合并
  let bytes = new Uint8Array(0);
  for (let i = 0; i < keys.length; i += 1) {
    bytes = concatBytes(bytes, serialize(keys[i]));
    bytes = concatBytes(bytes, serialize(map.get(keys[i])));
  }

  // 前面需要加上 LEB128 编码的 map size
  const lenBytes = encodeUintToLEB128(map.size);
  return concatBytes(lenBytes, bytes);
}

/**
 * 反序列化，只会取开头的有效字节
 * @param bytes 字节码
 * @returns 原数据
 */
// eslint-disable-next-line consistent-return
export function unserialize<T>(bytes: Uint8Array): T {
  checkSerializeType<T>();

  // array 递归
  if (isArray<T>()) {
    // @ts-ignore
    return unserializeArray<valueof<T>>(bytes);
  }

  // map 递归
  let map!: T;
  if (map instanceof Map) {
    // @ts-ignore
    return unserializeMap<indexof<T>, valueof<T>>(bytes);
  }

  // number or boolean 直接加载
  if (isInteger<T>() || isFloat<T>()) {
    return load<T>(bytes.dataStart);
  }

  if (isString<T>()) {
    // LEB128 字节长度
    const strLeb128Length = getLEB128FromBytes(bytes).byteLength;

    // 有效字节的总长度
    const serializedBytesLength = getSerializedBytesLength<T>(bytes);

    // 读取字符串 buffer
    const strBytes = bytes.subarray(strLeb128Length, serializedBytesLength);
    const strBuffer = bytesToBuffer(strBytes);

    // @ts-ignore
    return String.UTF8.decode(strBuffer);
  }

  unreachable();
}

/**
 * 反序列化数组，只会取开头的有效字节
 * @param bytes 字节码
 * @returns 原数据
 */
function unserializeArray<T>(bytes: Uint8Array): T[] {
  // 解析数组
  const arrLeb128Length = getLEB128FromBytes(bytes).byteLength;
  const arrLength = decodeLEB128ToUint(bytes);
  const arrBytes = bytes.subarray(arrLeb128Length);

  // 读取数据
  const arr = new Array<T>();
  const helper = new SerializeHelper(arrBytes);
  for (let i = 0; i < (arrLength as number); i += 1) {
    arr.push(helper.read<T>());
  }
  return arr;
}

/**
 * 反序列化 map，只会取开头的有效字节
 * @param bytes 字节码
 * @returns 原数据
 */
function unserializeMap<K, V>(bytes: Uint8Array): Map<K, V> {
  // 解析 map
  const mapLeb128Length = getLEB128FromBytes(bytes).byteLength;
  const mapSize = decodeLEB128ToUint(bytes);
  const mapBytes = bytes.subarray(mapLeb128Length);

  // 读取数据
  const map = new Map<K, V>();
  const helper = new SerializeHelper(mapBytes);
  for (let i = 0; i < (mapSize as number); i += 1) {
    map.set(helper.read<K>(), helper.read<V>());
  }
  return map;
}

/**
 * 获取被序列化过的数据的有效字节长度，只会取开头的有效字节
 * @param bytes 字节码
 * @returns 有效字节长度，有效字节 = LEB128 + data bytes
 */
// eslint-disable-next-line consistent-return
export function getSerializedBytesLength<T>(bytes: Uint8Array): u32 {
  checkSerializeType<T>();

  // array 递归
  if (isArray<T>()) {
    // @ts-ignore
    return getSerializedArrayBytesLength<valueof<T>>(bytes);
  }

  // map 递归
  let map!: T;
  if (map instanceof Map) {
    // @ts-ignore
    return getSerializedMapBytesLength<indexof<T>, valueof<T>>(bytes);
  }

  // number or boolean
  if (isInteger<T>() || isFloat<T>()) {
    return sizeof<T>();
  }

  if (isString<T>()) {
    // 开头的 LEB128 数据
    const strLeb128Length = getLEB128FromBytes(bytes).byteLength;
    const strBytesLength = decodeLEB128ToUint(bytes);

    // 有效字节的总长度
    return strLeb128Length + strBytesLength;
  }

  unreachable();
}

/**
 * 获取被序列化过的数组的有效字节长度，只会取开头的有效字节
 * @param bytes 字节码
 * @returns 有效字节长度，有效字节 = LEB128 + array bytes
 */
function getSerializedArrayBytesLength<T>(bytes: Uint8Array): u32 {
  // 数组元素个数
  const arrLength = decodeLEB128ToUint(bytes);

  // 开头 LEB128 的字节长度
  let length = getLEB128FromBytes(bytes).byteLength;

  for (let i = 0; i < (arrLength as number); i += 1) {
    length += getSerializedBytesLength<T>(bytes.subarray(length));
  }

  return length;
}

/**
 * 获取被序列化过的 map 的有效字节长度，只会取开头的有效字节
 * @param bytes 字节码
 * @returns 有效字节长度，有效字节 = LEB128 + map bytes
 */
function getSerializedMapBytesLength<K, V>(bytes: Uint8Array): u32 {
  // map size
  const arrLength = decodeLEB128ToUint(bytes);

  // 开头 LEB128 的字节长度
  let length = getLEB128FromBytes(bytes).byteLength;

  for (let i = 0; i < (arrLength as number); i += 1) {
    length += getSerializedBytesLength<K>(bytes.subarray(length));
    length += getSerializedBytesLength<V>(bytes.subarray(length));
  }

  return length;
}
