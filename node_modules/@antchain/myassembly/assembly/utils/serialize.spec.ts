import { getBytes } from './bytes';
import { checkSerializeType, serialize, unserialize } from './serialize';

describe('utils/serialize', () => {
  test('checkSerializeType', () => {
    expect(() => {
      // 基础类型
      checkSerializeType<bool>();
      checkSerializeType<number>();
      checkSerializeType<usize>();
      checkSerializeType<u8>();
      checkSerializeType<u16>();
      checkSerializeType<u32>();
      checkSerializeType<u64>();
      checkSerializeType<i8>();
      checkSerializeType<i16>();
      checkSerializeType<i32>();
      checkSerializeType<i64>();
      checkSerializeType<f32>();
      checkSerializeType<f64>();
      checkSerializeType<string>();

      // array
      checkSerializeType<bool[]>();
      checkSerializeType<number[]>();
      checkSerializeType<string[]>();

      // 嵌套 array
      checkSerializeType<bool[][]>();
      checkSerializeType<number[][][]>();
      checkSerializeType<string[][][][]>();

      // map
      checkSerializeType<Map<bool, bool>>();
      checkSerializeType<Map<bool, number>>();
      checkSerializeType<Map<bool, string>>();
      checkSerializeType<Map<number, bool>>();
      checkSerializeType<Map<number, number>>();
      checkSerializeType<Map<number, string>>();
      checkSerializeType<Map<string, bool>>();
      checkSerializeType<Map<string, number>>();
      checkSerializeType<Map<string, string>>();

      // 嵌套 map
      checkSerializeType<Map<Map<string, bool>, Map<string, number>>>();
      checkSerializeType<Map<Map<string, bool>, Map<Map<string, bool>, Map<string, number>>>>();

      // 复杂嵌套 array + map
      checkSerializeType<Map<string[], bool[]>>();
      checkSerializeType<Map<string[], number[][]>>();
      checkSerializeType<Map<string[], string[][][]>>();
      checkSerializeType<Map<string, number>[]>();
      checkSerializeType<Map<string, number>[][]>();
    }).not.toThrow();

    // 一些不支持序列化的类型，需要抛出错误
    expect(() => {
      checkSerializeType<symbol>();
    }).toThrow();
    expect(() => {
      checkSerializeType<Set<string>>();
    }).toThrow();
    expect(() => {
      checkSerializeType<ArrayBuffer>();
    }).toThrow();
    expect(() => {
      checkSerializeType<DataView>();
    }).toThrow();
    expect(() => {
      checkSerializeType<Error>();
    }).toThrow();
  });

  // ---------- 基础类型 ----------

  test('serialize<bool>(true)', () => {
    const value = true;
    const bytes = serialize(value);
    expect(bytes).toStrictEqual(getBytes<u8[]>([0x1]));
    expect(unserialize<bool>(bytes)).toBe(value);
  });

  test('serialize<bool>(false)', () => {
    const value = false;
    const bytes = serialize(value);
    expect(bytes).toStrictEqual(getBytes<u8[]>([0x0]));
    expect(unserialize<bool>(bytes)).toBe(value);
  });

  test('serialize<u8>', () => {
    const value: u8 = 123;
    const bytes = serialize(value);
    expect(bytes).toStrictEqual(getBytes<u8[]>([0x7b]));
    expect(unserialize<u8>(bytes)).toBe(value);
  });

  test('serialize<u16>', () => {
    const value: u16 = 12345;
    const bytes = serialize(value);
    expect(bytes).toStrictEqual(getBytes<u8[]>([0x39, 0x30]));
    expect(unserialize<u16>(bytes)).toBe(value);
  });

  test('serialize<u32>', () => {
    const value: u32 = 1234567890;
    const bytes = serialize(value);
    expect(bytes).toStrictEqual(getBytes<u8[]>([0xd2, 0x02, 0x96, 0x49]));
    expect(unserialize<u32>(bytes)).toBe(value);
  });

  test('serialize<u64>', () => {
    const value: u64 = 1234567890123;
    const bytes = serialize(value);
    expect(bytes).toStrictEqual(getBytes<u8[]>([0xcb, 0x04, 0xfb, 0x71, 0x1f, 0x01, 0x00, 0x00]));
    expect(unserialize<u64>(bytes)).toBe(value);
  });

  test('serialize<i8>', () => {
    const value: i8 = -123;
    const bytes = serialize(value);
    expect(bytes).toStrictEqual(getBytes<u8[]>([0x85]));
    expect(unserialize<i8>(bytes)).toBe(value);
  });

  test('serialize<i16>', () => {
    const value: i16 = -12345;
    const bytes = serialize(value);
    expect(bytes).toStrictEqual(getBytes<u8[]>([0xc7, 0xcf]));
    expect(unserialize<i16>(bytes)).toBe(value);
  });

  test('serialize<i32>', () => {
    const value: i32 = -1234567890;
    const bytes = serialize(value);
    expect(bytes).toStrictEqual(getBytes<u8[]>([0x2e, 0xfd, 0x69, 0xb6]));
    expect(unserialize<i32>(bytes)).toBe(value);
  });

  test('serialize<i64>', () => {
    const value: i64 = -1234567890123;
    const bytes = serialize(value);
    expect(bytes).toStrictEqual(getBytes<u8[]>([0x35, 0xfb, 0x04, 0x8e, 0xe0, 0xfe, 0xff, 0xff]));
    expect(unserialize<i64>(bytes)).toBe(value);
  });

  test('serialize<string>', () => {
    const value = 'hello myfish';
    const bytes = serialize(value);
    expect(bytes).toStrictEqual(
      getBytes<u8[]>([
        0x0c, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x6d, 0x79, 0x66, 0x69, 0x73, 0x68,
      ]),
    );
    expect(unserialize<string>(bytes)).toBe(value);
  });

  // ---------- array ----------

  test('serialize<u32[]>', () => {
    const arr: u32[] = [520, 1314, 666];
    const bytes = serialize(arr);
    expect(bytes).toStrictEqual(
      getBytes<u8[]>([
        // array length
        0x03,
        // 520
        0x08, 0x02, 0x00, 0x00,
        // 1314
        0x22, 0x05, 0x00, 0x00,
        // 666
        0x9a, 0x02, 0x00, 0x00,
      ]),
    );
    expect(unserialize<u32[]>(bytes)).toStrictEqual(arr);
  });

  test('serialize<string[]>', () => {
    const arr = ['hello', 'myfish'];
    const bytes = serialize(arr);
    expect(bytes).toStrictEqual(
      getBytes<u8[]>([
        // array length
        0x02,
        // hello
        0x05, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
        // myfish
        0x06, 0x6d, 0x79, 0x66, 0x69, 0x73, 0x68,
      ]),
    );
    expect(unserialize<string[]>(bytes)).toStrictEqual(arr);
  });

  // ---------- map ----------

  test('serialize<Map<string, u32>>', () => {
    const map = new Map<string, u32>();
    map.set('hello', 666);
    map.set('myfish', 888);
    const bytes = serialize(map);
    expect(bytes).toStrictEqual(
      getBytes<u8[]>([
        // map size
        0x02,
        // hello
        0x05, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
        // 666
        0x9a, 0x02, 0x00, 0x00,
        // myfish
        0x06, 0x6d, 0x79, 0x66, 0x69, 0x73, 0x68,
        // 888
        0x78, 0x03, 0x00, 0x00,
      ]),
    );
    expect(unserialize<Map<string, u32>>(bytes)).toStrictEqual(map);
  });
});
