import { my } from '.';

// 这个类只是对 getStorage / setStorage 的一个封装
// 主要有这些好处：
//  1. 内置初始化数据的逻辑，不用在部署时调用初始化方法，也不用再在合约中写 onDeploy 函数
//  2. 基于 AS 原生能力实现，后续扩展性强，等稳定之后再去增加语法糖，避免早期踩坑
//  3. 在创建实例的时候设置 storage key 和数据类型，方便、友好

const STORAGE_KEY_PREFIX: string = 'ms_'; // myfish_storage_

export class Storage<T> {
  private key: string;
  private value: T;

  constructor(key: string, initialValue: T) {
    this.key = STORAGE_KEY_PREFIX + key;

    // 查一下 storage size 来判断是否初始化过
    const dataSize = my.getStorageSize(this.key);

    if (dataSize > 0) {
      this.value = my.getStorage<T>(this.key);
    } else {
      // 初始化数据，并记录一下已经初始化过了
      my.setStorage(this.key, initialValue);
      this.value = initialValue;
    }
  }

  getData(): T {
    return this.value;
  }

  setData(value: T): void {
    this.value = value;
    my.setStorage(this.key, value);
  }

  toString(): string {
    return '[object Storage]';
  }
}

export class StorageMap<K, V> extends Storage<Map<K, V>> {
  hasItem(key: K): bool {
    const map = this.getData();
    return map.has(key);
  }

  getItem(key: K): V | null {
    const map = this.getData();
    return map.has(key) ? map.get(key) : null;
  }

  setItem(key: K, value: V): void {
    const map = this.getData();
    map.set(key, value);
    this.setData(map);
  }

  deleteItem(key: K): void {
    const map = this.getData();
    map.delete(key);
    this.setData(map);
  }
}
